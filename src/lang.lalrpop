use crate::*;

grammar(ctx: &mut Context<'input>);

pub xLang =  {
 Def*
}

Def = {
  FunctionDef,
  TypeDef,
}

TypeDef: () = {
  "type" <Ident> "{" <List<(<Ident> ":" <NonPtrType>)>> "}" => {ctx.init_struct(<>);}
}

FunctionDef: () = {
  <"kernel" ?> "fn" <Ident> "(" <List<( <Ident> ":" <InputType>)>> ")" <("->" "(" <List<(<Ident> ":" <OutputType>)>> ")")?> "{" <Statement*> "}" => ctx.func_def(<>)
}

Declspec = {
  "pub",
  "const",
}

#[inline]
DeclOrExpr: Statement<'input> = {
  <Expr> => Statement::Expr(<>),
  <Declspec?> <Type> <Ident> "=" <Composite>  => Statement::Decl(<>),
}

Statement: Statement<'input> = {
  "{" <mut v: Statement*> "}" => {
    let sz = v.len();
    match sz {
      0 => Statement::Void,
      1 => v.pop().unwrap(),
      _ => Statement::Block(v),
    }
  },
  <DeclOrExpr> ";",
  "if" "(" <Expr> ")"  "{" <Statement*> "}" <("else" "{" <Statement*> "}" )?> => Statement::If(<>),
  "while" "(" <Expr> ")" "{" <Statement*> "}" => Statement::While(<>),
  "for" "(" <P<DeclOrExpr>?> ";" <Expr?> ";" <Expr?>  ")" "{" <Statement*> "}" => Statement::For(<>),
}

#[inline]
List<T> : Vec<T> = <mut v:(<T> ",")*> <u:T?> => {
  if let Some(u) = u {
    v.push(u);
  }
  v
};


Composite = {
  <Expr>,
  "[" <List<Expr>> "]"  => Expr::List(<>),
}

Expr = {
  <Assign>,
}

Atom: Expr<'input> = {
  <Ident> => Expr::Ident(<>),
  <Literal>,
  "(" <Expr> ")",
  <InternType<Vector>> "(" <List<Expr>> ")" => Expr::Ctor(<>),
  <InternType<Matrix>> "(" <List<Expr>> ")" => Expr::Ctor(<>),
}

Postfix : Expr<'input> = {
  <Atom>,
  <P<Postfix>> "(" <List<Expr>> ")" => Expr::Call(<>),
  <P<Postfix>> "["  <P<Expr>> "]" => Expr::Subscript(<>),
  <P<Postfix>> "." <Ident> => Expr::Access(<>),
}

Unop: Expr<'input> = {
  <Postfix>,
  <"&">  <P<Unop>> => Expr::Unop(<>),
  <"*">  <P<Unop>> => Expr::Unop(<>),
  <"-">  <P<Unop>> => Expr::Unop(<>),
  <"+">  <P<Unop>> => Expr::Unop(<>),
  <"!">  <P<Unop>> => Expr::Unop(<>),
  <"++"> <P<Unop>> => Expr::Unop(<>),
  <"--"> <P<Unop>> => Expr::Unop(<>),
}

P<T> : Box<T> = T => Box::new(<>);
V<T> : Vec<T> = T => vec![<>];

Binop<Prev, Op>: Expr<'input> = {
  <Prev>,
  <P<Binop<Prev, Op>>> <Op> <P<Prev>> => Expr::Binop(<>),
}

Relop<Prev, Op>: Expr<'input> = {
  <Prev>,
  <P<Binop<Prev, Op>>> <Op> <P<Prev>> => Expr::Relop(<>),
}

Mulop = { "*", "/", "%"}
Addop = { "+", "-"}
Shlr = { "<<", ">>" }
Cmpop = {  "<", "<=", ">", ">="}
Equop = {  "==", "!=" }
Assignop = { "=", "+=", "-=", "*=", "/=", "%=" }

LogAndop = { "&&" }
LogOrop = { "||" }

Mul = Binop<Unop, Mulop>;
Add = Binop<Mul, Addop>;
Shift = Binop<Add, Shlr>;
Rel = Relop<Shift, Cmpop>;
Equ = Relop<Rel, Equop>;
BitAnd = Binop<Equ, "&">;
BitXor = Binop<BitAnd, "^">;
BitOr = Binop<BitXor, "|">;
LogAnd = Binop<BitOr, LogAndop>;
LogOr = Binop<LogAnd, LogOrop>;
Assign = Binop<LogOr, Assignop>;

Int: u32 = {
  <r"\d+">  => <>.parse().unwrap(),
}

Literal : Expr<'input> = {
  <Int>      => Expr::Uint(<>),
  <r"\d+\.\d+"> => Expr::Float(<>.parse().unwrap()),
}


Arr: Type<'input> = {
  "[" <Type> ":" <Int> "]" => Type::Arr(<>),
}

Image: Type<'input> = {
  "image1d" => Type::Image(Dim::_1D),
  "image2d" => Type::Image(Dim::_2D),
  "image3d" => Type::Image(Dim::_3D),
}

Scalar: Type<'input> = {
  "bool"  => Type::S(Bool),
  "int"   => Type::S(Sint(32)),
  "uint"  => Type::S(Uint(32)),
  "float" => Type::S(Real(32)),
}

Vector: Type<'input> = {
  "bool2"  => Type::V(Bool, 2),
  "int2"   => Type::V(Sint(32), 2),
  "uint2"  => Type::V(Uint(32), 2),
  "float2" => Type::V(Real(32), 2),
  "bool3"  => Type::V(Bool, 3),
  "int3"   => Type::V(Sint(32), 3),
  "uint3"  => Type::V(Uint(32), 3),
  "float3" => Type::V(Real(32), 3),
  "bool4"  => Type::V(Bool, 4),
  "int4"   => Type::V(Sint(32), 4),
  "uint4"  => Type::V(Uint(32), 4),
  "float4" => Type::V(Real(32), 4),
}

Matrix: Type<'input> = { 
  "mat2" => Type::M(Real(32), 2, 2),
  "mat3" => Type::M(Real(32), 3, 3),
  "mat4" => Type::M(Real(32), 4, 4),
}

Struct : InternedType<'input> = Ident => ctx.get_struct(<>);

#[inline]
InternType<T> : InternedType<'input> = T => ctx.get_type(Rc::new(<>));

#[inline]
NonPtrType: InternedType<'input> = {
  InternType<Scalar>,
  InternType<Vector>,
  InternType<Matrix>,
  InternType<Image>,
  InternType<Arr>,
  Struct,
}

Ptr: Type<'input> = {
  "[" <Type> "]" => Type::Ptr(<>, StorageClass::Function),
}

InputPtr: Type<'input> = {
  "[" <Type> "]"       => Type::Ptr(<>, StorageClass::UniformConstant),
  "mut" "[" <Type> "]" => Type::Ptr(<>, StorageClass::StorageBuffer),
}

OutputPtr: Type<'input> = {
  "[" <Type> "]" => Type::Ptr(<>, StorageClass::StorageBuffer),
}

Type: InternedType<'input> = {
  NonPtrType,
  InternType<Ptr>,
}

InputType: InternedType<'input> = {
  NonPtrType,
  InternType<InputPtr>,
}

OutputType: InternedType<'input> = {
  NonPtrType,
  InternType<OutputPtr>,
}


match {
  r"#.*\n" => {},
  r"\s" => {},
  "const",
  "pub",
  "kernel", "fn", "type", "mut", "if", "else", "while", "for",
  "*" ,"/", "%", "+", "-" ,"!" ,"++","--",
  "&&", "||", "|", "&", "^", "=", "+=", "-=", "*=", "/=", "%=",
  "<<", ">>", "<", "<=", ">", ">=", "==", "!=",
  ".", ":", ",", ";", "->",
  "[", "]",
  "{", "}",
  "(", ")",
  "mat2",
  "mat3",
  "mat4",
  "bool", "int",  "uint",  "float",
  "bool2", "int2", "uint2", "float2",
  "bool3", "int3", "uint3", "float3",
  "bool4", "int4", "uint4", "float4",
  "image1d","image2d", "image3d",
  r"\d+\.\d+",
  r"\d+",
  r"[a-zA-Z]\w*" => Ident,
}